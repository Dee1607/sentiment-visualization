{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/deeppatel/Desktop/Visualization/Project/csci6406_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _assertThisInitialized = require(\"/Users/deeppatel/Desktop/Visualization/Project/csci6406_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _createClass = require(\"/Users/deeppatel/Desktop/Visualization/Project/csci6406_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/deeppatel/Desktop/Visualization/Project/csci6406_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/Users/deeppatel/Desktop/Visualization/Project/csci6406_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/deeppatel/Desktop/Visualization/Project/csci6406_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/Users/deeppatel/Desktop/Visualization/Project/csci6406_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PythonShell = exports.NewlineTransformer = exports.PythonShellError = void 0;\n\nvar events_1 = require(\"events\");\n\nvar child_process_1 = require(\"child_process\");\n\nvar os_1 = require(\"os\");\n\nvar path_1 = require(\"path\");\n\nvar stream_1 = require(\"stream\");\n\nvar fs_1 = require(\"fs\");\n\nvar util_1 = require(\"util\");\n\nfunction toArray(source) {\n  if (typeof source === 'undefined' || source === null) {\n    return [];\n  } else if (!Array.isArray(source)) {\n    return [source];\n  }\n\n  return source;\n}\n/**\r\n * adds arguments as properties to obj\r\n */\n\n\nfunction extend(obj) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  Array.prototype.slice.call(arguments, 1).forEach(function (source) {\n    if (source) {\n      for (var key in source) {\n        obj[key] = source[key];\n      }\n    }\n  });\n  return obj;\n}\n/**\r\n * gets a random int from 0-10000000000\r\n */\n\n\nfunction getRandomInt() {\n  return Math.floor(Math.random() * 10000000000);\n}\n\nvar execPromise = (0, util_1.promisify)(child_process_1.exec);\n\nvar PythonShellError = /*#__PURE__*/function (_Error) {\n  _inherits(PythonShellError, _Error);\n\n  var _super = _createSuper(PythonShellError);\n\n  function PythonShellError() {\n    _classCallCheck(this, PythonShellError);\n\n    return _super.apply(this, arguments);\n  }\n\n  return _createClass(PythonShellError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.PythonShellError = PythonShellError;\n/**\r\n * Takes in a string stream and emits batches seperated by newlines\r\n */\n\nvar NewlineTransformer = /*#__PURE__*/function (_stream_1$Transform) {\n  _inherits(NewlineTransformer, _stream_1$Transform);\n\n  var _super2 = _createSuper(NewlineTransformer);\n\n  function NewlineTransformer() {\n    _classCallCheck(this, NewlineTransformer);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(NewlineTransformer, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      var data = chunk.toString();\n      if (this._lastLineData) data = this._lastLineData + data;\n      var lines = data.split(os_1.EOL);\n      this._lastLineData = lines.pop(); //@ts-ignore this works, node ignores the encoding if it's a number\n\n      lines.forEach(this.push.bind(this));\n      callback();\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(done) {\n      if (this._lastLineData) this.push(this._lastLineData);\n      this._lastLineData = null;\n      done();\n    }\n  }]);\n\n  return NewlineTransformer;\n}(stream_1.Transform);\n\nexports.NewlineTransformer = NewlineTransformer;\n/**\r\n * An interactive Python shell exchanging data through stdio\r\n * @param {string} script    The python script to execute\r\n * @param {object} [options] The launch options (also passed to child_process.spawn)\r\n * @param [stdoutSplitter] Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n * @param [stderrSplitter] Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n * @constructor\r\n */\n\nvar PythonShell = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(PythonShell, _events_1$EventEmitte);\n\n  var _super3 = _createSuper(PythonShell);\n\n  /**\r\n   * spawns a python process\r\n   * @param scriptPath path to script. Relative to current directory or options.scriptFolder if specified\r\n   * @param options\r\n   * @param stdoutSplitter Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n   * @param stderrSplitter Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n   */\n  function PythonShell(scriptPath, options) {\n    var _this;\n\n    var stdoutSplitter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var stderrSplitter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    _classCallCheck(this, PythonShell);\n\n    _this = _super3.call(this);\n    /**\r\n     * returns either pythonshell func (if val string) or custom func (if val Function)\r\n     */\n\n    function resolve(type, val) {\n      if (typeof val === 'string') {\n        // use a built-in function using its name\n        return PythonShell[type][val];\n      } else if (typeof val === 'function') {\n        // use a custom function\n        return val;\n      }\n    }\n\n    if (scriptPath.trim().length == 0) throw Error(\"scriptPath cannot be empty! You must give a script for python to run\");\n\n    var self = _assertThisInitialized(_this);\n\n    var errorData = '';\n    events_1.EventEmitter.call(_assertThisInitialized(_this));\n    options = extend({}, PythonShell.defaultOptions, options);\n    var pythonPath;\n\n    if (!options.pythonPath) {\n      pythonPath = PythonShell.defaultPythonPath;\n    } else pythonPath = options.pythonPath;\n\n    var pythonOptions = toArray(options.pythonOptions);\n    var scriptArgs = toArray(options.args);\n    _this.scriptPath = (0, path_1.join)(options.scriptPath || '', scriptPath);\n    _this.command = pythonOptions.concat(_this.scriptPath, scriptArgs);\n    _this.mode = options.mode || 'text';\n    _this.formatter = resolve('format', options.formatter || _this.mode);\n    _this.parser = resolve('parse', options.parser || _this.mode); // We don't expect users to ever format stderr as JSON so we default to text mode\n\n    _this.stderrParser = resolve('parse', options.stderrParser || 'text');\n    _this.terminated = false;\n    _this.childProcess = (0, child_process_1.spawn)(pythonPath, _this.command, options);\n    ['stdout', 'stdin', 'stderr'].forEach(function (name) {\n      self[name] = self.childProcess[name];\n      self.parser && self[name] && self[name].setEncoding(options.encoding || 'utf8');\n    }); // Node buffers stdout&stderr in batches regardless of newline placement\n    // This is troublesome if you want to recieve distinct individual messages\n    // for example JSON parsing breaks if it recieves partial JSON\n    // so we use newlineTransformer to emit each batch seperated by newline\n\n    if (_this.parser && _this.stdout) {\n      if (!stdoutSplitter) stdoutSplitter = new NewlineTransformer(); // note that setting the encoding turns the chunk into a string\n\n      stdoutSplitter.setEncoding(options.encoding || 'utf8');\n\n      _this.stdout.pipe(stdoutSplitter).on('data', function (chunk) {\n        _this.emit('message', self.parser(chunk));\n      });\n    } // listen to stderr and emit errors for incoming data\n\n\n    if (_this.stderrParser && _this.stderr) {\n      if (!stderrSplitter) stderrSplitter = new NewlineTransformer(); // note that setting the encoding turns the chunk into a string\n\n      stderrSplitter.setEncoding(options.encoding || 'utf8');\n\n      _this.stderr.pipe(stderrSplitter).on('data', function (chunk) {\n        _this.emit('stderr', self.stderrParser(chunk));\n      });\n    }\n\n    if (_this.stderr) {\n      _this.stderr.on('data', function (data) {\n        errorData += '' + data;\n      });\n\n      _this.stderr.on('end', function () {\n        self.stderrHasEnded = true;\n        terminateIfNeeded();\n      });\n    } else {\n      self.stderrHasEnded = true;\n    }\n\n    if (_this.stdout) {\n      _this.stdout.on('end', function () {\n        self.stdoutHasEnded = true;\n        terminateIfNeeded();\n      });\n    } else {\n      self.stdoutHasEnded = true;\n    }\n\n    _this.childProcess.on('error', function (err) {\n      self.emit('error', err);\n    });\n\n    _this.childProcess.on('exit', function (code, signal) {\n      self.exitCode = code;\n      self.exitSignal = signal;\n      terminateIfNeeded();\n    });\n\n    function terminateIfNeeded() {\n      if (!self.stderrHasEnded || !self.stdoutHasEnded || self.exitCode == null && self.exitSignal == null) return;\n      var err;\n\n      if (self.exitCode && self.exitCode !== 0) {\n        if (errorData) {\n          err = self.parseError(errorData);\n        } else {\n          err = new PythonShellError('process exited with code ' + self.exitCode);\n        }\n\n        err = extend(err, {\n          executable: pythonPath,\n          options: pythonOptions.length ? pythonOptions : null,\n          script: self.scriptPath,\n          args: scriptArgs.length ? scriptArgs : null,\n          exitCode: self.exitCode\n        }); // do not emit error if only a callback is used\n\n        if (self.listeners('pythonError').length || !self._endCallback) {\n          self.emit('pythonError', err);\n        }\n      }\n\n      self.terminated = true;\n      self.emit('close');\n      self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);\n    }\n\n    ;\n    return _this;\n  }\n  /**\r\n   * checks syntax without executing code\r\n   * @returns rejects promise w/ string error output if syntax failure\r\n   */\n\n\n  _createClass(PythonShell, [{\n    key: \"parseError\",\n    value:\n    /**\r\n     * Parses an error thrown from the Python process through stderr\r\n     * @param  {string|Buffer} data The stderr contents to parse\r\n     * @return {Error} The parsed error with extended stack trace when traceback is available\r\n     */\n    function parseError(data) {\n      var text = '' + data;\n      var error;\n\n      if (/^Traceback/.test(text)) {\n        // traceback data is available\n        var lines = text.trim().split(os_1.EOL);\n        var exception = lines.pop();\n        error = new PythonShellError(exception);\n        error.traceback = data; // extend stack trace\n\n        error.stack += os_1.EOL + '    ----- Python Traceback -----' + os_1.EOL + '  ';\n        error.stack += lines.slice(1).join(os_1.EOL + '  ');\n      } else {\n        // otherwise, create a simpler error with stderr contents\n        error = new PythonShellError(text);\n      }\n\n      return error;\n    }\n  }, {\n    key: \"send\",\n    value:\n    /**\r\n     * Sends a message to the Python shell through stdin\r\n     * Override this method to format data to be sent to the Python process\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\n    function send(message) {\n      if (!this.stdin) throw new Error(\"stdin not open for writing\");\n      var data = this.formatter ? this.formatter(message) : message;\n      if (this.mode !== 'binary') data += os_1.EOL;\n      this.stdin.write(data);\n      return this;\n    }\n  }, {\n    key: \"end\",\n    value:\n    /**\r\n     * Closes the stdin stream. Unless python is listening for stdin in a loop\r\n     * this should cause the process to finish its work and close.\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\n    function end(callback) {\n      if (this.childProcess.stdin) {\n        this.childProcess.stdin.end();\n      }\n\n      this._endCallback = callback;\n      return this;\n    }\n  }, {\n    key: \"kill\",\n    value:\n    /**\r\n     * Sends a kill signal to the process\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\n    function kill(signal) {\n      this.terminated = this.childProcess.kill(signal);\n      return this;\n    }\n  }, {\n    key: \"terminate\",\n    value:\n    /**\r\n     * Alias for kill.\r\n     * @deprecated\r\n     */\n    function terminate(signal) {\n      // todo: remove this next breaking release\n      return this.kill(signal);\n    }\n  }], [{\n    key: \"checkSyntax\",\n    value: function checkSyntax(code) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        var randomInt, filePath, writeFilePromise;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                randomInt = getRandomInt();\n                filePath = (0, os_1.tmpdir)() + path_1.sep + \"pythonShellSyntaxCheck\".concat(randomInt, \".py\");\n                writeFilePromise = (0, util_1.promisify)(fs_1.writeFile);\n                return _context.abrupt(\"return\", writeFilePromise(filePath, code).then(function () {\n                  return _this2.checkSyntaxFile(filePath);\n                }));\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n  }, {\n    key: \"getPythonPath\",\n    value: function getPythonPath() {\n      return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;\n    }\n    /**\r\n     * checks syntax without executing code\r\n     * @returns {Promise} rejects w/ stderr if syntax failure\r\n     */\n\n  }, {\n    key: \"checkSyntaxFile\",\n    value: function checkSyntaxFile(filePath) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var pythonPath, compileCommand;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                pythonPath = this.getPythonPath();\n                compileCommand = \"\".concat(pythonPath, \" -m py_compile \").concat(filePath);\n                return _context2.abrupt(\"return\", execPromise(compileCommand));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\r\n     * Runs a Python script and returns collected messages\r\n     * @param  {string}   scriptPath   The path to the script to execute\r\n     * @param  {Options}   options  The execution options\r\n     * @param  {Function} callback The callback function to invoke with the script results\r\n     * @return {PythonShell}       The PythonShell instance\r\n     */\n\n  }, {\n    key: \"run\",\n    value: function run(scriptPath, options, callback) {\n      var pyshell = new PythonShell(scriptPath, options);\n      var output = [];\n      return pyshell.on('message', function (message) {\n        output.push(message);\n      }).end(function (err) {\n        return callback(err ? err : null, output.length ? output : null);\n      });\n    }\n  }, {\n    key: \"runString\",\n    value:\n    /**\r\n     * Runs the inputted string of python code and returns collected messages. DO NOT ALLOW UNTRUSTED USER INPUT HERE!\r\n     * @param  {string}   code   The python code to execute\r\n     * @param  {Options}   options  The execution options\r\n     * @param  {Function} callback The callback function to invoke with the script results\r\n     * @return {PythonShell}       The PythonShell instance\r\n     */\n    function runString(code, options, callback) {\n      // put code in temp file\n      var randomInt = getRandomInt();\n      var filePath = os_1.tmpdir + path_1.sep + \"pythonShellFile\".concat(randomInt, \".py\");\n      (0, fs_1.writeFileSync)(filePath, code);\n      return PythonShell.run(filePath, options, callback);\n    }\n  }, {\n    key: \"getVersion\",\n    value: function getVersion(pythonPath) {\n      if (!pythonPath) pythonPath = this.getPythonPath();\n      return execPromise(pythonPath + \" --version\");\n    }\n  }, {\n    key: \"getVersionSync\",\n    value: function getVersionSync(pythonPath) {\n      if (!pythonPath) pythonPath = this.getPythonPath();\n      return (0, child_process_1.execSync)(pythonPath + \" --version\").toString();\n    }\n  }]);\n\n  return PythonShell;\n}(events_1.EventEmitter);\n\nexports.PythonShell = PythonShell; // starting 2020 python2 is deprecated so we choose 3 as default\n\nPythonShell.defaultPythonPath = process.platform != \"win32\" ? \"python3\" : \"python\";\nPythonShell.defaultOptions = {}; //allow global overrides for options\n// built-in formatters\n\nPythonShell.format = {\n  text: function toText(data) {\n    if (!data) return '';else if (typeof data !== 'string') return data.toString();\n    return data;\n  },\n  json: function toJson(data) {\n    return JSON.stringify(data);\n  }\n}; //built-in parsers\n\nPythonShell.parse = {\n  text: function asText(data) {\n    return data;\n  },\n  json: function asJson(data) {\n    return JSON.parse(data);\n  }\n};\n;","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PythonShell = exports.NewlineTransformer = exports.PythonShellError = void 0;\r\nconst events_1 = require(\"events\");\r\nconst child_process_1 = require(\"child_process\");\r\nconst os_1 = require(\"os\");\r\nconst path_1 = require(\"path\");\r\nconst stream_1 = require(\"stream\");\r\nconst fs_1 = require(\"fs\");\r\nconst util_1 = require(\"util\");\r\nfunction toArray(source) {\r\n    if (typeof source === 'undefined' || source === null) {\r\n        return [];\r\n    }\r\n    else if (!Array.isArray(source)) {\r\n        return [source];\r\n    }\r\n    return source;\r\n}\r\n/**\r\n * adds arguments as properties to obj\r\n */\r\nfunction extend(obj, ...args) {\r\n    Array.prototype.slice.call(arguments, 1).forEach(function (source) {\r\n        if (source) {\r\n            for (let key in source) {\r\n                obj[key] = source[key];\r\n            }\r\n        }\r\n    });\r\n    return obj;\r\n}\r\n/**\r\n * gets a random int from 0-10000000000\r\n */\r\nfunction getRandomInt() {\r\n    return Math.floor(Math.random() * 10000000000);\r\n}\r\nconst execPromise = (0, util_1.promisify)(child_process_1.exec);\r\nclass PythonShellError extends Error {\r\n}\r\nexports.PythonShellError = PythonShellError;\r\n/**\r\n * Takes in a string stream and emits batches seperated by newlines\r\n */\r\nclass NewlineTransformer extends stream_1.Transform {\r\n    _transform(chunk, encoding, callback) {\r\n        let data = chunk.toString();\r\n        if (this._lastLineData)\r\n            data = this._lastLineData + data;\r\n        const lines = data.split(os_1.EOL);\r\n        this._lastLineData = lines.pop();\r\n        //@ts-ignore this works, node ignores the encoding if it's a number\r\n        lines.forEach(this.push.bind(this));\r\n        callback();\r\n    }\r\n    _flush(done) {\r\n        if (this._lastLineData)\r\n            this.push(this._lastLineData);\r\n        this._lastLineData = null;\r\n        done();\r\n    }\r\n}\r\nexports.NewlineTransformer = NewlineTransformer;\r\n/**\r\n * An interactive Python shell exchanging data through stdio\r\n * @param {string} script    The python script to execute\r\n * @param {object} [options] The launch options (also passed to child_process.spawn)\r\n * @param [stdoutSplitter] Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n * @param [stderrSplitter] Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n * @constructor\r\n */\r\nclass PythonShell extends events_1.EventEmitter {\r\n    /**\r\n     * spawns a python process\r\n     * @param scriptPath path to script. Relative to current directory or options.scriptFolder if specified\r\n     * @param options\r\n     * @param stdoutSplitter Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n     * @param stderrSplitter Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n     */\r\n    constructor(scriptPath, options, stdoutSplitter = null, stderrSplitter = null) {\r\n        super();\r\n        /**\r\n         * returns either pythonshell func (if val string) or custom func (if val Function)\r\n         */\r\n        function resolve(type, val) {\r\n            if (typeof val === 'string') {\r\n                // use a built-in function using its name\r\n                return PythonShell[type][val];\r\n            }\r\n            else if (typeof val === 'function') {\r\n                // use a custom function\r\n                return val;\r\n            }\r\n        }\r\n        if (scriptPath.trim().length == 0)\r\n            throw Error(\"scriptPath cannot be empty! You must give a script for python to run\");\r\n        let self = this;\r\n        let errorData = '';\r\n        events_1.EventEmitter.call(this);\r\n        options = extend({}, PythonShell.defaultOptions, options);\r\n        let pythonPath;\r\n        if (!options.pythonPath) {\r\n            pythonPath = PythonShell.defaultPythonPath;\r\n        }\r\n        else\r\n            pythonPath = options.pythonPath;\r\n        let pythonOptions = toArray(options.pythonOptions);\r\n        let scriptArgs = toArray(options.args);\r\n        this.scriptPath = (0, path_1.join)(options.scriptPath || '', scriptPath);\r\n        this.command = pythonOptions.concat(this.scriptPath, scriptArgs);\r\n        this.mode = options.mode || 'text';\r\n        this.formatter = resolve('format', options.formatter || this.mode);\r\n        this.parser = resolve('parse', options.parser || this.mode);\r\n        // We don't expect users to ever format stderr as JSON so we default to text mode\r\n        this.stderrParser = resolve('parse', options.stderrParser || 'text');\r\n        this.terminated = false;\r\n        this.childProcess = (0, child_process_1.spawn)(pythonPath, this.command, options);\r\n        ['stdout', 'stdin', 'stderr'].forEach(function (name) {\r\n            self[name] = self.childProcess[name];\r\n            self.parser && self[name] && self[name].setEncoding(options.encoding || 'utf8');\r\n        });\r\n        // Node buffers stdout&stderr in batches regardless of newline placement\r\n        // This is troublesome if you want to recieve distinct individual messages\r\n        // for example JSON parsing breaks if it recieves partial JSON\r\n        // so we use newlineTransformer to emit each batch seperated by newline\r\n        if (this.parser && this.stdout) {\r\n            if (!stdoutSplitter)\r\n                stdoutSplitter = new NewlineTransformer();\r\n            // note that setting the encoding turns the chunk into a string\r\n            stdoutSplitter.setEncoding(options.encoding || 'utf8');\r\n            this.stdout.pipe(stdoutSplitter).on('data', (chunk) => {\r\n                this.emit('message', self.parser(chunk));\r\n            });\r\n        }\r\n        // listen to stderr and emit errors for incoming data\r\n        if (this.stderrParser && this.stderr) {\r\n            if (!stderrSplitter)\r\n                stderrSplitter = new NewlineTransformer();\r\n            // note that setting the encoding turns the chunk into a string\r\n            stderrSplitter.setEncoding(options.encoding || 'utf8');\r\n            this.stderr.pipe(stderrSplitter).on('data', (chunk) => {\r\n                this.emit('stderr', self.stderrParser(chunk));\r\n            });\r\n        }\r\n        if (this.stderr) {\r\n            this.stderr.on('data', function (data) {\r\n                errorData += '' + data;\r\n            });\r\n            this.stderr.on('end', function () {\r\n                self.stderrHasEnded = true;\r\n                terminateIfNeeded();\r\n            });\r\n        }\r\n        else {\r\n            self.stderrHasEnded = true;\r\n        }\r\n        if (this.stdout) {\r\n            this.stdout.on('end', function () {\r\n                self.stdoutHasEnded = true;\r\n                terminateIfNeeded();\r\n            });\r\n        }\r\n        else {\r\n            self.stdoutHasEnded = true;\r\n        }\r\n        this.childProcess.on('error', function (err) {\r\n            self.emit('error', err);\r\n        });\r\n        this.childProcess.on('exit', function (code, signal) {\r\n            self.exitCode = code;\r\n            self.exitSignal = signal;\r\n            terminateIfNeeded();\r\n        });\r\n        function terminateIfNeeded() {\r\n            if (!self.stderrHasEnded || !self.stdoutHasEnded || (self.exitCode == null && self.exitSignal == null))\r\n                return;\r\n            let err;\r\n            if (self.exitCode && self.exitCode !== 0) {\r\n                if (errorData) {\r\n                    err = self.parseError(errorData);\r\n                }\r\n                else {\r\n                    err = new PythonShellError('process exited with code ' + self.exitCode);\r\n                }\r\n                err = extend(err, {\r\n                    executable: pythonPath,\r\n                    options: pythonOptions.length ? pythonOptions : null,\r\n                    script: self.scriptPath,\r\n                    args: scriptArgs.length ? scriptArgs : null,\r\n                    exitCode: self.exitCode\r\n                });\r\n                // do not emit error if only a callback is used\r\n                if (self.listeners('pythonError').length || !self._endCallback) {\r\n                    self.emit('pythonError', err);\r\n                }\r\n            }\r\n            self.terminated = true;\r\n            self.emit('close');\r\n            self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);\r\n        }\r\n        ;\r\n    }\r\n    /**\r\n     * checks syntax without executing code\r\n     * @returns rejects promise w/ string error output if syntax failure\r\n     */\r\n    static checkSyntax(code) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const randomInt = getRandomInt();\r\n            const filePath = (0, os_1.tmpdir)() + path_1.sep + `pythonShellSyntaxCheck${randomInt}.py`;\r\n            const writeFilePromise = (0, util_1.promisify)(fs_1.writeFile);\r\n            return writeFilePromise(filePath, code).then(() => {\r\n                return this.checkSyntaxFile(filePath);\r\n            });\r\n        });\r\n    }\r\n    static getPythonPath() {\r\n        return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;\r\n    }\r\n    /**\r\n     * checks syntax without executing code\r\n     * @returns {Promise} rejects w/ stderr if syntax failure\r\n     */\r\n    static checkSyntaxFile(filePath) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const pythonPath = this.getPythonPath();\r\n            let compileCommand = `${pythonPath} -m py_compile ${filePath}`;\r\n            return execPromise(compileCommand);\r\n        });\r\n    }\r\n    /**\r\n     * Runs a Python script and returns collected messages\r\n     * @param  {string}   scriptPath   The path to the script to execute\r\n     * @param  {Options}   options  The execution options\r\n     * @param  {Function} callback The callback function to invoke with the script results\r\n     * @return {PythonShell}       The PythonShell instance\r\n     */\r\n    static run(scriptPath, options, callback) {\r\n        let pyshell = new PythonShell(scriptPath, options);\r\n        let output = [];\r\n        return pyshell.on('message', function (message) {\r\n            output.push(message);\r\n        }).end(function (err) {\r\n            return callback(err ? err : null, output.length ? output : null);\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * Runs the inputted string of python code and returns collected messages. DO NOT ALLOW UNTRUSTED USER INPUT HERE!\r\n     * @param  {string}   code   The python code to execute\r\n     * @param  {Options}   options  The execution options\r\n     * @param  {Function} callback The callback function to invoke with the script results\r\n     * @return {PythonShell}       The PythonShell instance\r\n     */\r\n    static runString(code, options, callback) {\r\n        // put code in temp file\r\n        const randomInt = getRandomInt();\r\n        const filePath = os_1.tmpdir + path_1.sep + `pythonShellFile${randomInt}.py`;\r\n        (0, fs_1.writeFileSync)(filePath, code);\r\n        return PythonShell.run(filePath, options, callback);\r\n    }\r\n    ;\r\n    static getVersion(pythonPath) {\r\n        if (!pythonPath)\r\n            pythonPath = this.getPythonPath();\r\n        return execPromise(pythonPath + \" --version\");\r\n    }\r\n    static getVersionSync(pythonPath) {\r\n        if (!pythonPath)\r\n            pythonPath = this.getPythonPath();\r\n        return (0, child_process_1.execSync)(pythonPath + \" --version\").toString();\r\n    }\r\n    /**\r\n     * Parses an error thrown from the Python process through stderr\r\n     * @param  {string|Buffer} data The stderr contents to parse\r\n     * @return {Error} The parsed error with extended stack trace when traceback is available\r\n     */\r\n    parseError(data) {\r\n        let text = '' + data;\r\n        let error;\r\n        if (/^Traceback/.test(text)) {\r\n            // traceback data is available\r\n            let lines = text.trim().split(os_1.EOL);\r\n            let exception = lines.pop();\r\n            error = new PythonShellError(exception);\r\n            error.traceback = data;\r\n            // extend stack trace\r\n            error.stack += os_1.EOL + '    ----- Python Traceback -----' + os_1.EOL + '  ';\r\n            error.stack += lines.slice(1).join(os_1.EOL + '  ');\r\n        }\r\n        else {\r\n            // otherwise, create a simpler error with stderr contents\r\n            error = new PythonShellError(text);\r\n        }\r\n        return error;\r\n    }\r\n    ;\r\n    /**\r\n     * Sends a message to the Python shell through stdin\r\n     * Override this method to format data to be sent to the Python process\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\r\n    send(message) {\r\n        if (!this.stdin)\r\n            throw new Error(\"stdin not open for writing\");\r\n        let data = this.formatter ? this.formatter(message) : message;\r\n        if (this.mode !== 'binary')\r\n            data += os_1.EOL;\r\n        this.stdin.write(data);\r\n        return this;\r\n    }\r\n    ;\r\n    /**\r\n     * Closes the stdin stream. Unless python is listening for stdin in a loop\r\n     * this should cause the process to finish its work and close.\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\r\n    end(callback) {\r\n        if (this.childProcess.stdin) {\r\n            this.childProcess.stdin.end();\r\n        }\r\n        this._endCallback = callback;\r\n        return this;\r\n    }\r\n    ;\r\n    /**\r\n     * Sends a kill signal to the process\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\r\n    kill(signal) {\r\n        this.terminated = this.childProcess.kill(signal);\r\n        return this;\r\n    }\r\n    ;\r\n    /**\r\n     * Alias for kill.\r\n     * @deprecated\r\n     */\r\n    terminate(signal) {\r\n        // todo: remove this next breaking release\r\n        return this.kill(signal);\r\n    }\r\n}\r\nexports.PythonShell = PythonShell;\r\n// starting 2020 python2 is deprecated so we choose 3 as default\r\nPythonShell.defaultPythonPath = process.platform != \"win32\" ? \"python3\" : \"python\";\r\nPythonShell.defaultOptions = {}; //allow global overrides for options\r\n// built-in formatters\r\nPythonShell.format = {\r\n    text: function toText(data) {\r\n        if (!data)\r\n            return '';\r\n        else if (typeof data !== 'string')\r\n            return data.toString();\r\n        return data;\r\n    },\r\n    json: function toJson(data) {\r\n        return JSON.stringify(data);\r\n    }\r\n};\r\n//built-in parsers\r\nPythonShell.parse = {\r\n    text: function asText(data) {\r\n        return data;\r\n    },\r\n    json: function asJson(data) {\r\n        return JSON.parse(data);\r\n    }\r\n};\r\n;\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}